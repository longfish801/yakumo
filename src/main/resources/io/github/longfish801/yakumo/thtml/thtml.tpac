#! clmap:thtml
#>

#> closure
	BLtxt bltxt = bltxtMap[resultKey]
	binds = [
		title: clmap.cl('/textize#meta').call(bltxt, 'タイトル', '（無題）'),
		header: clmap.cl('/thtml/bind#header').call(bltxt),
		toc: clmap.cl('/thtml/bind#toc').call(bltxt),
		bodytext: clmap.cl('/htmlize').call(bltxt.root),
		note: clmap.cl('/thtml/bind#note').call(bltxt),
	]
#-dec
	import io.github.longfish801.bltxt.BLtxt
#-args
	String resultKey
	Map bltxtMap
	Map appendMap
#-return
	Map binds
#-prefix
	clmap.cl('/util').properties['resultKey'] = resultKey
	clmap.cl('/util/log#debug').call('BGN thtml', [])
#-suffix
	clmap.cl('/util/log#debug').call('END thtml', [])
#>

#> map:bind
#-dec
	import io.github.longfish801.bltxt.BLtxt
#-args
	BLtxt bltxt
#-return
	String html
#-prefix
	def templater = clmap.cl('/util#template')
	String templateKey = "${clmap.path}/data:template#"
#>> data:template
#-header
<div class="col-lg-8">
<h1>${title}</h1>
<% if (!subtitle.empty){ %><div id="subtitle">${subtitle}</div><% } %>
</div>
<% if (!pubdate.empty || !author.empty){ %><div class="col-lg-4 text-end">
<% if (!pubdate.empty){ %><div id="pubdate">公開日 ${pubdate}</div><% } %>
<% if (!author.empty){ %><div id="author">${author}</div><% } %>
</div><% } %>
#-toc <li class="nav-item toc_h${level}"><a href="#id${id}" class="nav-link">${text}</a></li>
#-note
<dt><a name="t${id}" href="#f${id}">[*${id}]</a></dt>
<dd>${text}</dd>
#>> closure:header
	Closure htmlizerMeta = { String name, String dflt ->
		return clmap.cl('/htmlize#meta').call(bltxt, name, dflt)
	}
	// タイトル、サブタイトル、公開日、著者名のためのHTMLを返します
	html = templater.call(templateKey + 'header', [
		title: htmlizerMeta.call('タイトル', '（無題）'),
		subtitle: htmlizerMeta.call('サブタイトル', ''),
		pubdate: htmlizerMeta.call('公開日', ''),
		author: htmlizerMeta.call('著者名', ''),
	])
#>> closure:toc
	// 目次を生成します
	List list = []
	bltxt.grepNodes('block', '見出し').each { def node ->
		int level = clmap.cl('/htmlize/headline#level').call(node)
		list << templater.call(templateKey + 'toc', [
			text: clmap.cl('/textize').call(node),
			level: level,
			id: "${level}_${node.serialNo}"
		])
	}
	html = list.join(System.lineSeparator())
#>> closure:note
	// 註のノードと、そのキーを収集します
	List noteList = bltxt.grepNodes('inline', '註')
	List noteKeys = []
	noteList.each { noteKeys << it.attrs[0] }
	if (noteKeys.size() == 0) return ''
	
	// 註記のノードと、そのキーを収集します
	List cmntList = bltxt.grepNodes('meta', '註記')
	List cmntKeys = []
	Map cmntMap = [:]
	cmntList.each {
		cmntKeys << it.attrs[0]
		cmntMap[it.attrs[0]] = it
	}
	
	// キーの重複や過不足をチェックします
	if (noteKeys.unique(false).size() < noteKeys.size()){
		Map map = [:]
		noteKeys.each { map[it] = (map.containsKey(it))? ++ map[it] : 1 }
		clmap.cl('/util/fprint#warn').call("註のキーに重複があります。重複キー=%s", [map.findAll { it.value > 1 }.keySet()])
		return ''
	}
	List diff1 = noteKeys - cmntKeys
	if (diff1.size() > 0){
		clmap.cl('/util/fprint#warn').call("註に対する註記の記述漏れがあります。diff=%s", [diff1])
		return ''
	}
	List diff2 = cmntKeys - noteKeys
	if (diff2.size() > 0){
		clmap.cl('/util/fprint#warn').call("不要な註記あるいは註の記述漏れがあります。diff=%s", [diff2])
		return ''
	}
	
	// 註記を生成します
	List list = []
	noteKeys.eachWithIndex { String noteKey, int cnt ->
		list << templater.call(templateKey + 'note', [
			text: clmap.cl('/htmlize').call(cmntMap[noteKey]),
			id: cnt + 1
		])
	}
	html = list.join(System.lineSeparator())
#>

